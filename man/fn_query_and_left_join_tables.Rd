% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/export.R
\name{fn_query_and_left_join_tables}
\alias{fn_query_and_left_join_tables}
\title{Query and join tables along common column/s}
\usage{
fn_query_and_left_join_tables(
  database,
  list_tables_and_filters,
  unique_column_name = NULL,
  verbose = TRUE
)
}
\arguments{
\item{database}{an open SQLite database connection}

\item{list_tables_and_filters}{a list of lists, where each list corresponds to,
and named after a table in the database, they contain:
- key_names: a vector of column names corresponding to the identifying columns
where at least one column is common across all the listed tables
- column_names: a vector of column names to be included in the output table,
where "*" means all columns in the table
- list_filters: a list of named vectors where each vector refers to a valid
column name in the specified table with the values to be selected.
A numeric column is always specified as a range of values, i.e. minimum and
maximum values, but these can be the same value, and the same numeric column
can be included multiple times with various ranges which is equivalent to
using a vector of values or ranges of values to filter.
A text column is always specified by a vector of strings.}

\item{unique_column_name}{a common column name across all included tables in
\code{list_tables_and_filters} which we are requiring to be unique after filtering.
(Default=NULL)}

\item{verbose}{Show messages? (Default=TRUE)}
}
\value{
\itemize{
\item Ok:
merged data frame including all the columns requested per table, and
all the rows passing the filtering requirements listed in
\code{list_tables_and_filters}.
\item Err: dbError
}
}
\description{
Query and join tables along common column/s
}
\examples{
list_fnames_tables = fn_simulate_tables(
     n_entries=50,
     n_dates=3,
     n_sites=3,
     n_treatments=3,
     n_loci=10e3,
     save_data_tables=TRUE)$list_fnames_tables
list_df_data_tables = list(
    df_phenotypes=utils::read.delim(list_fnames_tables$fname_phenotypes, 
         header=TRUE),
    df_environments=utils::read.delim(list_fnames_tables$fname_environments, 
         header=TRUE),
    df_genotypes=utils::read.delim(list_fnames_tables$fname_genotypes, 
         header=TRUE, check.names=FALSE))
fn_initialise_db(fname_db="test.sqlite", 
         list_df_data_tables=list_df_data_tables, verbose=TRUE)
database = DBI::dbConnect(drv=RSQLite::SQLite(), dbname="test.sqlite")
list_tables_and_filters = list(
    entries=list(
        key_names=c("ENTRY_UID"), 
        column_names=c("*"),
        list_filters=list(
            ENTRY=sample(unique(list_df_data_tables$df_phenotypes$ENTRY), 
                 size=min(c(10, 
                 length(unique(list_df_data_tables$df_phenotypes$ENTRY))))),
            POPULATION=list_df_data_tables$df_phenotypes$POPULATION[1])
    ),
    phenotypes=list(
        key_names=c("ENTRY_UID", "REPLICATION", "TREATMENT", "SITE", "FVI_YEAR_SEASON"),
        column_names=c("*"),
        list_filters=list(
            REPLICATION="rep_1",
            SITE=list_df_data_tables$df_phenotypes$SITE[1],
            POSIX_DATE_TIME=list_df_data_tables$df_phenotypes$POSIX_DATE_TIME[1],
            TREATMENT=sample(unique(list_df_data_tables$df_phenotypes$TREATMENT), 
                 size=min(c(1, 
                 length(unique(list_df_data_tables$df_phenotypes$TREATMENT))))))
    ),
     genotypes=list(
        key_names=c("ENTRY_UID"),
        column_names=c("*"),
        list_filters=NULL
    )
)
df_query = fn_query_and_left_join_tables(database=database, 
     list_tables_and_filters=list_tables_and_filters, unique_column_name="ENTRY_UID")
DBI::dbDisconnect(database)
unlink("test.sqlite")
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/export.R
\name{fn_check_export_inputs}
\alias{fn_check_export_inputs}
\title{Check the validity of exportation function inputs}
\usage{
fn_check_export_inputs(
  database,
  table_name,
  list_filters = NULL,
  vec_columns_to_show = "*",
  unique_column_name = NULL
)
}
\arguments{
\item{database}{an open SQLite database connection}

\item{table_name}{name of the (entries, dates, sites, treatments, traits, abiotics,
and loci) or data (phenotypes, environments and genotypes) table represented by df}

\item{list_filters}{list of named vectors where each vector refers to a valid
column name in the specified table with the values to be selected.
A numeric column is always specified as a range of values, i.e. minimum and maximum values,
but these can be the same value, and the same numeric column can be included multiple times with
various ranges which is equivalent to using a vector of values or ranges of values to filter.
A text column is always specified by a vector of strings. (Default=NULL)}

\item{vec_columns_to_show}{vector of column names to include, where "\emph{" means all
columns in the table. (Default="}")}

\item{unique_column_name}{column name which we are targetting to be unique after filtering.
Note that we do not explicitly test if the values in this column are actually unique
just that this column exists. (Default=NULL)}
}
\value{
\itemize{
\item Ok:
NULL
\item Err: dbError
}
}
\description{
Check the validity of exportation function inputs
}
\examples{
list_fnames_tables = fn_simulate_tables(
     n_entries=50,
     n_dates=3,
     n_sites=3,
     n_treatments=3,
     n_loci=10e3,
     save_data_tables=TRUE)$list_fnames_tables
list_df_data_tables = list(
    df_phenotypes=utils::read.delim(list_fnames_tables$fname_phenotypes, 
         header=TRUE),
    df_environments=utils::read.delim(list_fnames_tables$fname_environments, 
         header=TRUE),
    df_genotypes=utils::read.delim(list_fnames_tables$fname_genotypes, 
         header=TRUE, check.names=FALSE))
fn_initialise_db(fname_db="test.sqlite", 
         list_df_data_tables=list_df_data_tables, verbose=TRUE)
database = DBI::dbConnect(drv=RSQLite::SQLite(), dbname="test.sqlite")
list_filters=list(
    REPLICATION="rep_1",
    TREATMENT=sample(unique(list_df_data_tables$df_phenotypes$TREATMENT), 
        size=min(c(2, length(unique(list_df_data_tables$df_phenotypes$TREATMENT)))))
)
null_error = fn_check_export_inputs(database=database, table_name="phenotypes",
     list_filters=list_filters, vec_columns_to_show="*", unique_column_name="ENTRY")
non_null_error_1 = fn_check_export_inputs(database=database, 
     table_name="non_existent_table", list_filters=list_filters)
non_null_error_2 = fn_check_export_inputs(database=database, table_name="entries",
     vec_columns_to_show="non_existent_column")
DBI::dbDisconnect(database)
unlink("test.sqlite")
}

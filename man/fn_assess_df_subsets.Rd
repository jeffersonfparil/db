% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/export.R
\name{fn_assess_df_subsets}
\alias{fn_assess_df_subsets}
\title{Assess the number of unique elements in each column of a table after an optional filtering}
\usage{
fn_assess_df_subsets(
  database,
  table_name,
  list_filters = NULL,
  vec_column_names_to_count = NULL,
  verbose = TRUE
)
}
\arguments{
\item{database}{an open SQLite database connection}

\item{table_name}{name of the (entries, dates, sites, treatments, traits, abiotics,
and loci) or data (phenotypes, environments and genotypes) table represented by df}

\item{list_filters}{list of named vectors where each vector refers to a valid
column name in the specified table with the values to be selected.
A numeric column is always specified as a range of values, i.e. minimum and maximum values,
but these can be the same value, and the same numeric column can be included multiple times with
various ranges which is equivalent to using a vector of values or ranges of values to filter.
A text column is always specified by a vector of strings. (Default=NULL)}

\item{vec_column_names_to_count}{vector of column names for which the unique elements will be
counted. If NULL, then all the required columns of the table will be used. (Default=NULL)}

\item{verbose}{Show messages? (Default=TRUE)}
}
\value{
\itemize{
\item Ok:
$df_all_possible_combinations: data frame of all possible combinations of the elements
of the columns used for filtering (see \code{list_filters}), and the corresponding
numbers of unique elements found in each columns requested to be counted
(see \code{vec_column_names_to_count})
$list_per_combination: list of vectors of counts of each unique element per combination of
filtering columns (see \code{list_filters}), and
columns to count (see \code{vec_column_names_to_count})
\item Err: dbError
}
}
\description{
Assess the number of unique elements in each column of a table after an optional filtering
}
\examples{
list_fnames_tables = fn_simulate_tables(
     n_entries=50,
     n_dates=3,
     n_sites=3,
     n_treatments=3,
     n_loci=10e3,
     save_data_tables=TRUE)$list_fnames_tables
fname_db = "test.sqlite"
df_allele_frequency_table = utils::read.delim(
         list_fnames_tables$fname_genotypes, 
         header=TRUE, check.names=FALSE)
list_df_data_tables = list(
    df_phenotypes=utils::read.delim(list_fnames_tables$fname_phenotypes, header=TRUE),
    df_environments=utils::read.delim(list_fnames_tables$fname_environments, header=TRUE),
    df_genotypes=df_allele_frequency_table)
fn_initialise_db(fname_db=fname_db, list_df_data_tables=list_df_data_tables, verbose=TRUE)
database = DBI::dbConnect(drv=RSQLite::SQLite(), dbname=fname_db)
table_name = "phenotypes"
list_filters=list(
            REPLICATION="*",
            MONTH=c(1, 12),
            TREATMENT=sample(unique(list_df_data_tables$df_phenotypes$TREATMENT), 
                 size=min(c(2, length(unique(list_df_data_tables$df_phenotypes$TREATMENT)))))
            )
list_counts = fn_assess_df_subsets(database=database, table_name=table_name, 
     list_filters=list_filters, vec_column_names_to_count=NULL, verbose=TRUE)
DBI::dbDisconnect(database)
unlink("test.sqlite")
}
